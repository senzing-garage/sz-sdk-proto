// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: g2product.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_g2product_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_g2product_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_g2product_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_g2product_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_g2product_2eproto;
namespace g2product {
class DestroyRequest;
struct DestroyRequestDefaultTypeInternal;
extern DestroyRequestDefaultTypeInternal _DestroyRequest_default_instance_;
class DestroyResponse;
struct DestroyResponseDefaultTypeInternal;
extern DestroyResponseDefaultTypeInternal _DestroyResponse_default_instance_;
class InitRequest;
struct InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class InitResponse;
struct InitResponseDefaultTypeInternal;
extern InitResponseDefaultTypeInternal _InitResponse_default_instance_;
class LicenseRequest;
struct LicenseRequestDefaultTypeInternal;
extern LicenseRequestDefaultTypeInternal _LicenseRequest_default_instance_;
class LicenseResponse;
struct LicenseResponseDefaultTypeInternal;
extern LicenseResponseDefaultTypeInternal _LicenseResponse_default_instance_;
class ValidateLicenseFileRequest;
struct ValidateLicenseFileRequestDefaultTypeInternal;
extern ValidateLicenseFileRequestDefaultTypeInternal _ValidateLicenseFileRequest_default_instance_;
class ValidateLicenseFileResponse;
struct ValidateLicenseFileResponseDefaultTypeInternal;
extern ValidateLicenseFileResponseDefaultTypeInternal _ValidateLicenseFileResponse_default_instance_;
class ValidateLicenseStringBase64Request;
struct ValidateLicenseStringBase64RequestDefaultTypeInternal;
extern ValidateLicenseStringBase64RequestDefaultTypeInternal _ValidateLicenseStringBase64Request_default_instance_;
class ValidateLicenseStringBase64Response;
struct ValidateLicenseStringBase64ResponseDefaultTypeInternal;
extern ValidateLicenseStringBase64ResponseDefaultTypeInternal _ValidateLicenseStringBase64Response_default_instance_;
class VersionRequest;
struct VersionRequestDefaultTypeInternal;
extern VersionRequestDefaultTypeInternal _VersionRequest_default_instance_;
class VersionResponse;
struct VersionResponseDefaultTypeInternal;
extern VersionResponseDefaultTypeInternal _VersionResponse_default_instance_;
}  // namespace g2product
PROTOBUF_NAMESPACE_OPEN
template<> ::g2product::DestroyRequest* Arena::CreateMaybeMessage<::g2product::DestroyRequest>(Arena*);
template<> ::g2product::DestroyResponse* Arena::CreateMaybeMessage<::g2product::DestroyResponse>(Arena*);
template<> ::g2product::InitRequest* Arena::CreateMaybeMessage<::g2product::InitRequest>(Arena*);
template<> ::g2product::InitResponse* Arena::CreateMaybeMessage<::g2product::InitResponse>(Arena*);
template<> ::g2product::LicenseRequest* Arena::CreateMaybeMessage<::g2product::LicenseRequest>(Arena*);
template<> ::g2product::LicenseResponse* Arena::CreateMaybeMessage<::g2product::LicenseResponse>(Arena*);
template<> ::g2product::ValidateLicenseFileRequest* Arena::CreateMaybeMessage<::g2product::ValidateLicenseFileRequest>(Arena*);
template<> ::g2product::ValidateLicenseFileResponse* Arena::CreateMaybeMessage<::g2product::ValidateLicenseFileResponse>(Arena*);
template<> ::g2product::ValidateLicenseStringBase64Request* Arena::CreateMaybeMessage<::g2product::ValidateLicenseStringBase64Request>(Arena*);
template<> ::g2product::ValidateLicenseStringBase64Response* Arena::CreateMaybeMessage<::g2product::ValidateLicenseStringBase64Response>(Arena*);
template<> ::g2product::VersionRequest* Arena::CreateMaybeMessage<::g2product::VersionRequest>(Arena*);
template<> ::g2product::VersionResponse* Arena::CreateMaybeMessage<::g2product::VersionResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace g2product {

// ===================================================================

class DestroyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2product.DestroyRequest) */ {
 public:
  inline DestroyRequest() : DestroyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DestroyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyRequest(const DestroyRequest& from);
  DestroyRequest(DestroyRequest&& from) noexcept
    : DestroyRequest() {
    *this = ::std::move(from);
  }

  inline DestroyRequest& operator=(const DestroyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyRequest& operator=(DestroyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyRequest*>(
               &_DestroyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DestroyRequest& a, DestroyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.DestroyRequest";
  }
  protected:
  explicit DestroyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2product.DestroyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class DestroyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2product.DestroyResponse) */ {
 public:
  inline DestroyResponse() : DestroyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DestroyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyResponse(const DestroyResponse& from);
  DestroyResponse(DestroyResponse&& from) noexcept
    : DestroyResponse() {
    *this = ::std::move(from);
  }

  inline DestroyResponse& operator=(const DestroyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyResponse& operator=(DestroyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyResponse* internal_default_instance() {
    return reinterpret_cast<const DestroyResponse*>(
               &_DestroyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DestroyResponse& a, DestroyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DestroyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DestroyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.DestroyResponse";
  }
  protected:
  explicit DestroyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2product.DestroyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class InitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2product.InitRequest) */ {
 public:
  inline InitRequest() : InitRequest(nullptr) {}
  ~InitRequest() override;
  explicit PROTOBUF_CONSTEXPR InitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitRequest(const InitRequest& from);
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitRequest& from) {
    InitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.InitRequest";
  }
  protected:
  explicit InitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleNameFieldNumber = 1,
    kIniParamsFieldNumber = 2,
    kVerboseLoggingFieldNumber = 3,
  };
  // string moduleName = 1;
  void clear_modulename();
  const std::string& modulename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modulename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modulename();
  PROTOBUF_NODISCARD std::string* release_modulename();
  void set_allocated_modulename(std::string* modulename);
  private:
  const std::string& _internal_modulename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modulename(const std::string& value);
  std::string* _internal_mutable_modulename();
  public:

  // string iniParams = 2;
  void clear_iniparams();
  const std::string& iniparams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iniparams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iniparams();
  PROTOBUF_NODISCARD std::string* release_iniparams();
  void set_allocated_iniparams(std::string* iniparams);
  private:
  const std::string& _internal_iniparams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iniparams(const std::string& value);
  std::string* _internal_mutable_iniparams();
  public:

  // int32 verboseLogging = 3;
  void clear_verboselogging();
  int32_t verboselogging() const;
  void set_verboselogging(int32_t value);
  private:
  int32_t _internal_verboselogging() const;
  void _internal_set_verboselogging(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:g2product.InitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modulename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iniparams_;
    int32_t verboselogging_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class InitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2product.InitResponse) */ {
 public:
  inline InitResponse() : InitResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR InitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitResponse(const InitResponse& from);
  InitResponse(InitResponse&& from) noexcept
    : InitResponse() {
    *this = ::std::move(from);
  }

  inline InitResponse& operator=(const InitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitResponse& operator=(InitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitResponse* internal_default_instance() {
    return reinterpret_cast<const InitResponse*>(
               &_InitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InitResponse& a, InitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.InitResponse";
  }
  protected:
  explicit InitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2product.InitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class LicenseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2product.LicenseRequest) */ {
 public:
  inline LicenseRequest() : LicenseRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LicenseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LicenseRequest(const LicenseRequest& from);
  LicenseRequest(LicenseRequest&& from) noexcept
    : LicenseRequest() {
    *this = ::std::move(from);
  }

  inline LicenseRequest& operator=(const LicenseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseRequest& operator=(LicenseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LicenseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LicenseRequest* internal_default_instance() {
    return reinterpret_cast<const LicenseRequest*>(
               &_LicenseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LicenseRequest& a, LicenseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LicenseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LicenseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LicenseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LicenseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.LicenseRequest";
  }
  protected:
  explicit LicenseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2product.LicenseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class LicenseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2product.LicenseResponse) */ {
 public:
  inline LicenseResponse() : LicenseResponse(nullptr) {}
  ~LicenseResponse() override;
  explicit PROTOBUF_CONSTEXPR LicenseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LicenseResponse(const LicenseResponse& from);
  LicenseResponse(LicenseResponse&& from) noexcept
    : LicenseResponse() {
    *this = ::std::move(from);
  }

  inline LicenseResponse& operator=(const LicenseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseResponse& operator=(LicenseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LicenseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LicenseResponse* internal_default_instance() {
    return reinterpret_cast<const LicenseResponse*>(
               &_LicenseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LicenseResponse& a, LicenseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LicenseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LicenseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LicenseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LicenseResponse& from) {
    LicenseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LicenseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.LicenseResponse";
  }
  protected:
  explicit LicenseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2product.LicenseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class ValidateLicenseFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2product.ValidateLicenseFileRequest) */ {
 public:
  inline ValidateLicenseFileRequest() : ValidateLicenseFileRequest(nullptr) {}
  ~ValidateLicenseFileRequest() override;
  explicit PROTOBUF_CONSTEXPR ValidateLicenseFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateLicenseFileRequest(const ValidateLicenseFileRequest& from);
  ValidateLicenseFileRequest(ValidateLicenseFileRequest&& from) noexcept
    : ValidateLicenseFileRequest() {
    *this = ::std::move(from);
  }

  inline ValidateLicenseFileRequest& operator=(const ValidateLicenseFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateLicenseFileRequest& operator=(ValidateLicenseFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateLicenseFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateLicenseFileRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateLicenseFileRequest*>(
               &_ValidateLicenseFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ValidateLicenseFileRequest& a, ValidateLicenseFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateLicenseFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateLicenseFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateLicenseFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateLicenseFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateLicenseFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateLicenseFileRequest& from) {
    ValidateLicenseFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateLicenseFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.ValidateLicenseFileRequest";
  }
  protected:
  explicit ValidateLicenseFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseFilePathFieldNumber = 1,
  };
  // string licenseFilePath = 1;
  void clear_licensefilepath();
  const std::string& licensefilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_licensefilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_licensefilepath();
  PROTOBUF_NODISCARD std::string* release_licensefilepath();
  void set_allocated_licensefilepath(std::string* licensefilepath);
  private:
  const std::string& _internal_licensefilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_licensefilepath(const std::string& value);
  std::string* _internal_mutable_licensefilepath();
  public:

  // @@protoc_insertion_point(class_scope:g2product.ValidateLicenseFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr licensefilepath_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class ValidateLicenseFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2product.ValidateLicenseFileResponse) */ {
 public:
  inline ValidateLicenseFileResponse() : ValidateLicenseFileResponse(nullptr) {}
  ~ValidateLicenseFileResponse() override;
  explicit PROTOBUF_CONSTEXPR ValidateLicenseFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateLicenseFileResponse(const ValidateLicenseFileResponse& from);
  ValidateLicenseFileResponse(ValidateLicenseFileResponse&& from) noexcept
    : ValidateLicenseFileResponse() {
    *this = ::std::move(from);
  }

  inline ValidateLicenseFileResponse& operator=(const ValidateLicenseFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateLicenseFileResponse& operator=(ValidateLicenseFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateLicenseFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateLicenseFileResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateLicenseFileResponse*>(
               &_ValidateLicenseFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ValidateLicenseFileResponse& a, ValidateLicenseFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateLicenseFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateLicenseFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateLicenseFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateLicenseFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateLicenseFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateLicenseFileResponse& from) {
    ValidateLicenseFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateLicenseFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.ValidateLicenseFileResponse";
  }
  protected:
  explicit ValidateLicenseFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2product.ValidateLicenseFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class ValidateLicenseStringBase64Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2product.ValidateLicenseStringBase64Request) */ {
 public:
  inline ValidateLicenseStringBase64Request() : ValidateLicenseStringBase64Request(nullptr) {}
  ~ValidateLicenseStringBase64Request() override;
  explicit PROTOBUF_CONSTEXPR ValidateLicenseStringBase64Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateLicenseStringBase64Request(const ValidateLicenseStringBase64Request& from);
  ValidateLicenseStringBase64Request(ValidateLicenseStringBase64Request&& from) noexcept
    : ValidateLicenseStringBase64Request() {
    *this = ::std::move(from);
  }

  inline ValidateLicenseStringBase64Request& operator=(const ValidateLicenseStringBase64Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateLicenseStringBase64Request& operator=(ValidateLicenseStringBase64Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateLicenseStringBase64Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateLicenseStringBase64Request* internal_default_instance() {
    return reinterpret_cast<const ValidateLicenseStringBase64Request*>(
               &_ValidateLicenseStringBase64Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ValidateLicenseStringBase64Request& a, ValidateLicenseStringBase64Request& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateLicenseStringBase64Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateLicenseStringBase64Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateLicenseStringBase64Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateLicenseStringBase64Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateLicenseStringBase64Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateLicenseStringBase64Request& from) {
    ValidateLicenseStringBase64Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateLicenseStringBase64Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.ValidateLicenseStringBase64Request";
  }
  protected:
  explicit ValidateLicenseStringBase64Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicenseStringFieldNumber = 1,
  };
  // string licenseString = 1;
  void clear_licensestring();
  const std::string& licensestring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_licensestring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_licensestring();
  PROTOBUF_NODISCARD std::string* release_licensestring();
  void set_allocated_licensestring(std::string* licensestring);
  private:
  const std::string& _internal_licensestring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_licensestring(const std::string& value);
  std::string* _internal_mutable_licensestring();
  public:

  // @@protoc_insertion_point(class_scope:g2product.ValidateLicenseStringBase64Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr licensestring_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class ValidateLicenseStringBase64Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2product.ValidateLicenseStringBase64Response) */ {
 public:
  inline ValidateLicenseStringBase64Response() : ValidateLicenseStringBase64Response(nullptr) {}
  ~ValidateLicenseStringBase64Response() override;
  explicit PROTOBUF_CONSTEXPR ValidateLicenseStringBase64Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateLicenseStringBase64Response(const ValidateLicenseStringBase64Response& from);
  ValidateLicenseStringBase64Response(ValidateLicenseStringBase64Response&& from) noexcept
    : ValidateLicenseStringBase64Response() {
    *this = ::std::move(from);
  }

  inline ValidateLicenseStringBase64Response& operator=(const ValidateLicenseStringBase64Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateLicenseStringBase64Response& operator=(ValidateLicenseStringBase64Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateLicenseStringBase64Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateLicenseStringBase64Response* internal_default_instance() {
    return reinterpret_cast<const ValidateLicenseStringBase64Response*>(
               &_ValidateLicenseStringBase64Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ValidateLicenseStringBase64Response& a, ValidateLicenseStringBase64Response& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateLicenseStringBase64Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateLicenseStringBase64Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateLicenseStringBase64Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateLicenseStringBase64Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateLicenseStringBase64Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateLicenseStringBase64Response& from) {
    ValidateLicenseStringBase64Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateLicenseStringBase64Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.ValidateLicenseStringBase64Response";
  }
  protected:
  explicit ValidateLicenseStringBase64Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2product.ValidateLicenseStringBase64Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class VersionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2product.VersionRequest) */ {
 public:
  inline VersionRequest() : VersionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR VersionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionRequest(const VersionRequest& from);
  VersionRequest(VersionRequest&& from) noexcept
    : VersionRequest() {
    *this = ::std::move(from);
  }

  inline VersionRequest& operator=(const VersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionRequest& operator=(VersionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionRequest* internal_default_instance() {
    return reinterpret_cast<const VersionRequest*>(
               &_VersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VersionRequest& a, VersionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VersionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.VersionRequest";
  }
  protected:
  explicit VersionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2product.VersionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2product_2eproto;
};
// -------------------------------------------------------------------

class VersionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2product.VersionResponse) */ {
 public:
  inline VersionResponse() : VersionResponse(nullptr) {}
  ~VersionResponse() override;
  explicit PROTOBUF_CONSTEXPR VersionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionResponse(const VersionResponse& from);
  VersionResponse(VersionResponse&& from) noexcept
    : VersionResponse() {
    *this = ::std::move(from);
  }

  inline VersionResponse& operator=(const VersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionResponse& operator=(VersionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionResponse* internal_default_instance() {
    return reinterpret_cast<const VersionResponse*>(
               &_VersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VersionResponse& a, VersionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VersionResponse& from) {
    VersionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2product.VersionResponse";
  }
  protected:
  explicit VersionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2product.VersionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2product_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DestroyRequest

// -------------------------------------------------------------------

// DestroyResponse

// -------------------------------------------------------------------

// InitRequest

// string moduleName = 1;
inline void InitRequest::clear_modulename() {
  _impl_.modulename_.ClearToEmpty();
}
inline const std::string& InitRequest::modulename() const {
  // @@protoc_insertion_point(field_get:g2product.InitRequest.moduleName)
  return _internal_modulename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitRequest::set_modulename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modulename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.InitRequest.moduleName)
}
inline std::string* InitRequest::mutable_modulename() {
  std::string* _s = _internal_mutable_modulename();
  // @@protoc_insertion_point(field_mutable:g2product.InitRequest.moduleName)
  return _s;
}
inline const std::string& InitRequest::_internal_modulename() const {
  return _impl_.modulename_.Get();
}
inline void InitRequest::_internal_set_modulename(const std::string& value) {
  
  _impl_.modulename_.Set(value, GetArenaForAllocation());
}
inline std::string* InitRequest::_internal_mutable_modulename() {
  
  return _impl_.modulename_.Mutable(GetArenaForAllocation());
}
inline std::string* InitRequest::release_modulename() {
  // @@protoc_insertion_point(field_release:g2product.InitRequest.moduleName)
  return _impl_.modulename_.Release();
}
inline void InitRequest::set_allocated_modulename(std::string* modulename) {
  if (modulename != nullptr) {
    
  } else {
    
  }
  _impl_.modulename_.SetAllocated(modulename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modulename_.IsDefault()) {
    _impl_.modulename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.InitRequest.moduleName)
}

// string iniParams = 2;
inline void InitRequest::clear_iniparams() {
  _impl_.iniparams_.ClearToEmpty();
}
inline const std::string& InitRequest::iniparams() const {
  // @@protoc_insertion_point(field_get:g2product.InitRequest.iniParams)
  return _internal_iniparams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitRequest::set_iniparams(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iniparams_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.InitRequest.iniParams)
}
inline std::string* InitRequest::mutable_iniparams() {
  std::string* _s = _internal_mutable_iniparams();
  // @@protoc_insertion_point(field_mutable:g2product.InitRequest.iniParams)
  return _s;
}
inline const std::string& InitRequest::_internal_iniparams() const {
  return _impl_.iniparams_.Get();
}
inline void InitRequest::_internal_set_iniparams(const std::string& value) {
  
  _impl_.iniparams_.Set(value, GetArenaForAllocation());
}
inline std::string* InitRequest::_internal_mutable_iniparams() {
  
  return _impl_.iniparams_.Mutable(GetArenaForAllocation());
}
inline std::string* InitRequest::release_iniparams() {
  // @@protoc_insertion_point(field_release:g2product.InitRequest.iniParams)
  return _impl_.iniparams_.Release();
}
inline void InitRequest::set_allocated_iniparams(std::string* iniparams) {
  if (iniparams != nullptr) {
    
  } else {
    
  }
  _impl_.iniparams_.SetAllocated(iniparams, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iniparams_.IsDefault()) {
    _impl_.iniparams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.InitRequest.iniParams)
}

// int32 verboseLogging = 3;
inline void InitRequest::clear_verboselogging() {
  _impl_.verboselogging_ = 0;
}
inline int32_t InitRequest::_internal_verboselogging() const {
  return _impl_.verboselogging_;
}
inline int32_t InitRequest::verboselogging() const {
  // @@protoc_insertion_point(field_get:g2product.InitRequest.verboseLogging)
  return _internal_verboselogging();
}
inline void InitRequest::_internal_set_verboselogging(int32_t value) {
  
  _impl_.verboselogging_ = value;
}
inline void InitRequest::set_verboselogging(int32_t value) {
  _internal_set_verboselogging(value);
  // @@protoc_insertion_point(field_set:g2product.InitRequest.verboseLogging)
}

// -------------------------------------------------------------------

// InitResponse

// -------------------------------------------------------------------

// LicenseRequest

// -------------------------------------------------------------------

// LicenseResponse

// string result = 1;
inline void LicenseResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& LicenseResponse::result() const {
  // @@protoc_insertion_point(field_get:g2product.LicenseResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LicenseResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.LicenseResponse.result)
}
inline std::string* LicenseResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2product.LicenseResponse.result)
  return _s;
}
inline const std::string& LicenseResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void LicenseResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* LicenseResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* LicenseResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2product.LicenseResponse.result)
  return _impl_.result_.Release();
}
inline void LicenseResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.LicenseResponse.result)
}

// -------------------------------------------------------------------

// ValidateLicenseFileRequest

// string licenseFilePath = 1;
inline void ValidateLicenseFileRequest::clear_licensefilepath() {
  _impl_.licensefilepath_.ClearToEmpty();
}
inline const std::string& ValidateLicenseFileRequest::licensefilepath() const {
  // @@protoc_insertion_point(field_get:g2product.ValidateLicenseFileRequest.licenseFilePath)
  return _internal_licensefilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateLicenseFileRequest::set_licensefilepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.licensefilepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.ValidateLicenseFileRequest.licenseFilePath)
}
inline std::string* ValidateLicenseFileRequest::mutable_licensefilepath() {
  std::string* _s = _internal_mutable_licensefilepath();
  // @@protoc_insertion_point(field_mutable:g2product.ValidateLicenseFileRequest.licenseFilePath)
  return _s;
}
inline const std::string& ValidateLicenseFileRequest::_internal_licensefilepath() const {
  return _impl_.licensefilepath_.Get();
}
inline void ValidateLicenseFileRequest::_internal_set_licensefilepath(const std::string& value) {
  
  _impl_.licensefilepath_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateLicenseFileRequest::_internal_mutable_licensefilepath() {
  
  return _impl_.licensefilepath_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateLicenseFileRequest::release_licensefilepath() {
  // @@protoc_insertion_point(field_release:g2product.ValidateLicenseFileRequest.licenseFilePath)
  return _impl_.licensefilepath_.Release();
}
inline void ValidateLicenseFileRequest::set_allocated_licensefilepath(std::string* licensefilepath) {
  if (licensefilepath != nullptr) {
    
  } else {
    
  }
  _impl_.licensefilepath_.SetAllocated(licensefilepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.licensefilepath_.IsDefault()) {
    _impl_.licensefilepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.ValidateLicenseFileRequest.licenseFilePath)
}

// -------------------------------------------------------------------

// ValidateLicenseFileResponse

// string result = 1;
inline void ValidateLicenseFileResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& ValidateLicenseFileResponse::result() const {
  // @@protoc_insertion_point(field_get:g2product.ValidateLicenseFileResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateLicenseFileResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.ValidateLicenseFileResponse.result)
}
inline std::string* ValidateLicenseFileResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2product.ValidateLicenseFileResponse.result)
  return _s;
}
inline const std::string& ValidateLicenseFileResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void ValidateLicenseFileResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateLicenseFileResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateLicenseFileResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2product.ValidateLicenseFileResponse.result)
  return _impl_.result_.Release();
}
inline void ValidateLicenseFileResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.ValidateLicenseFileResponse.result)
}

// -------------------------------------------------------------------

// ValidateLicenseStringBase64Request

// string licenseString = 1;
inline void ValidateLicenseStringBase64Request::clear_licensestring() {
  _impl_.licensestring_.ClearToEmpty();
}
inline const std::string& ValidateLicenseStringBase64Request::licensestring() const {
  // @@protoc_insertion_point(field_get:g2product.ValidateLicenseStringBase64Request.licenseString)
  return _internal_licensestring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateLicenseStringBase64Request::set_licensestring(ArgT0&& arg0, ArgT... args) {
 
 _impl_.licensestring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.ValidateLicenseStringBase64Request.licenseString)
}
inline std::string* ValidateLicenseStringBase64Request::mutable_licensestring() {
  std::string* _s = _internal_mutable_licensestring();
  // @@protoc_insertion_point(field_mutable:g2product.ValidateLicenseStringBase64Request.licenseString)
  return _s;
}
inline const std::string& ValidateLicenseStringBase64Request::_internal_licensestring() const {
  return _impl_.licensestring_.Get();
}
inline void ValidateLicenseStringBase64Request::_internal_set_licensestring(const std::string& value) {
  
  _impl_.licensestring_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateLicenseStringBase64Request::_internal_mutable_licensestring() {
  
  return _impl_.licensestring_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateLicenseStringBase64Request::release_licensestring() {
  // @@protoc_insertion_point(field_release:g2product.ValidateLicenseStringBase64Request.licenseString)
  return _impl_.licensestring_.Release();
}
inline void ValidateLicenseStringBase64Request::set_allocated_licensestring(std::string* licensestring) {
  if (licensestring != nullptr) {
    
  } else {
    
  }
  _impl_.licensestring_.SetAllocated(licensestring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.licensestring_.IsDefault()) {
    _impl_.licensestring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.ValidateLicenseStringBase64Request.licenseString)
}

// -------------------------------------------------------------------

// ValidateLicenseStringBase64Response

// string result = 1;
inline void ValidateLicenseStringBase64Response::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& ValidateLicenseStringBase64Response::result() const {
  // @@protoc_insertion_point(field_get:g2product.ValidateLicenseStringBase64Response.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateLicenseStringBase64Response::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.ValidateLicenseStringBase64Response.result)
}
inline std::string* ValidateLicenseStringBase64Response::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2product.ValidateLicenseStringBase64Response.result)
  return _s;
}
inline const std::string& ValidateLicenseStringBase64Response::_internal_result() const {
  return _impl_.result_.Get();
}
inline void ValidateLicenseStringBase64Response::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateLicenseStringBase64Response::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateLicenseStringBase64Response::release_result() {
  // @@protoc_insertion_point(field_release:g2product.ValidateLicenseStringBase64Response.result)
  return _impl_.result_.Release();
}
inline void ValidateLicenseStringBase64Response::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.ValidateLicenseStringBase64Response.result)
}

// -------------------------------------------------------------------

// VersionRequest

// -------------------------------------------------------------------

// VersionResponse

// string result = 1;
inline void VersionResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& VersionResponse::result() const {
  // @@protoc_insertion_point(field_get:g2product.VersionResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2product.VersionResponse.result)
}
inline std::string* VersionResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2product.VersionResponse.result)
  return _s;
}
inline const std::string& VersionResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void VersionResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2product.VersionResponse.result)
  return _impl_.result_.Release();
}
inline void VersionResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2product.VersionResponse.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace g2product

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_g2product_2eproto
