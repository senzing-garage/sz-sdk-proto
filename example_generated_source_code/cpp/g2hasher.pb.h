// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: g2hasher.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_g2hasher_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_g2hasher_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_g2hasher_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_g2hasher_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_g2hasher_2eproto;
namespace g2hasher {
class ClearLastExceptionRequest;
struct ClearLastExceptionRequestDefaultTypeInternal;
extern ClearLastExceptionRequestDefaultTypeInternal _ClearLastExceptionRequest_default_instance_;
class ClearLastExceptionResponse;
struct ClearLastExceptionResponseDefaultTypeInternal;
extern ClearLastExceptionResponseDefaultTypeInternal _ClearLastExceptionResponse_default_instance_;
class DestroyRequest;
struct DestroyRequestDefaultTypeInternal;
extern DestroyRequestDefaultTypeInternal _DestroyRequest_default_instance_;
class DestroyResponse;
struct DestroyResponseDefaultTypeInternal;
extern DestroyResponseDefaultTypeInternal _DestroyResponse_default_instance_;
class ExportTokenLibraryRequest;
struct ExportTokenLibraryRequestDefaultTypeInternal;
extern ExportTokenLibraryRequestDefaultTypeInternal _ExportTokenLibraryRequest_default_instance_;
class ExportTokenLibraryResponse;
struct ExportTokenLibraryResponseDefaultTypeInternal;
extern ExportTokenLibraryResponseDefaultTypeInternal _ExportTokenLibraryResponse_default_instance_;
class GetLastExceptionCodeRequest;
struct GetLastExceptionCodeRequestDefaultTypeInternal;
extern GetLastExceptionCodeRequestDefaultTypeInternal _GetLastExceptionCodeRequest_default_instance_;
class GetLastExceptionCodeResponse;
struct GetLastExceptionCodeResponseDefaultTypeInternal;
extern GetLastExceptionCodeResponseDefaultTypeInternal _GetLastExceptionCodeResponse_default_instance_;
class GetLastExceptionRequest;
struct GetLastExceptionRequestDefaultTypeInternal;
extern GetLastExceptionRequestDefaultTypeInternal _GetLastExceptionRequest_default_instance_;
class GetLastExceptionResponse;
struct GetLastExceptionResponseDefaultTypeInternal;
extern GetLastExceptionResponseDefaultTypeInternal _GetLastExceptionResponse_default_instance_;
class InitRequest;
struct InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class InitResponse;
struct InitResponseDefaultTypeInternal;
extern InitResponseDefaultTypeInternal _InitResponse_default_instance_;
class InitWithConfigRequest;
struct InitWithConfigRequestDefaultTypeInternal;
extern InitWithConfigRequestDefaultTypeInternal _InitWithConfigRequest_default_instance_;
class InitWithConfigResponse;
struct InitWithConfigResponseDefaultTypeInternal;
extern InitWithConfigResponseDefaultTypeInternal _InitWithConfigResponse_default_instance_;
class ProcessRequest;
struct ProcessRequestDefaultTypeInternal;
extern ProcessRequestDefaultTypeInternal _ProcessRequest_default_instance_;
class ProcessResponse;
struct ProcessResponseDefaultTypeInternal;
extern ProcessResponseDefaultTypeInternal _ProcessResponse_default_instance_;
}  // namespace g2hasher
PROTOBUF_NAMESPACE_OPEN
template<> ::g2hasher::ClearLastExceptionRequest* Arena::CreateMaybeMessage<::g2hasher::ClearLastExceptionRequest>(Arena*);
template<> ::g2hasher::ClearLastExceptionResponse* Arena::CreateMaybeMessage<::g2hasher::ClearLastExceptionResponse>(Arena*);
template<> ::g2hasher::DestroyRequest* Arena::CreateMaybeMessage<::g2hasher::DestroyRequest>(Arena*);
template<> ::g2hasher::DestroyResponse* Arena::CreateMaybeMessage<::g2hasher::DestroyResponse>(Arena*);
template<> ::g2hasher::ExportTokenLibraryRequest* Arena::CreateMaybeMessage<::g2hasher::ExportTokenLibraryRequest>(Arena*);
template<> ::g2hasher::ExportTokenLibraryResponse* Arena::CreateMaybeMessage<::g2hasher::ExportTokenLibraryResponse>(Arena*);
template<> ::g2hasher::GetLastExceptionCodeRequest* Arena::CreateMaybeMessage<::g2hasher::GetLastExceptionCodeRequest>(Arena*);
template<> ::g2hasher::GetLastExceptionCodeResponse* Arena::CreateMaybeMessage<::g2hasher::GetLastExceptionCodeResponse>(Arena*);
template<> ::g2hasher::GetLastExceptionRequest* Arena::CreateMaybeMessage<::g2hasher::GetLastExceptionRequest>(Arena*);
template<> ::g2hasher::GetLastExceptionResponse* Arena::CreateMaybeMessage<::g2hasher::GetLastExceptionResponse>(Arena*);
template<> ::g2hasher::InitRequest* Arena::CreateMaybeMessage<::g2hasher::InitRequest>(Arena*);
template<> ::g2hasher::InitResponse* Arena::CreateMaybeMessage<::g2hasher::InitResponse>(Arena*);
template<> ::g2hasher::InitWithConfigRequest* Arena::CreateMaybeMessage<::g2hasher::InitWithConfigRequest>(Arena*);
template<> ::g2hasher::InitWithConfigResponse* Arena::CreateMaybeMessage<::g2hasher::InitWithConfigResponse>(Arena*);
template<> ::g2hasher::ProcessRequest* Arena::CreateMaybeMessage<::g2hasher::ProcessRequest>(Arena*);
template<> ::g2hasher::ProcessResponse* Arena::CreateMaybeMessage<::g2hasher::ProcessResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace g2hasher {

// ===================================================================

class ClearLastExceptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.ClearLastExceptionRequest) */ {
 public:
  inline ClearLastExceptionRequest() : ClearLastExceptionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ClearLastExceptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearLastExceptionRequest(const ClearLastExceptionRequest& from);
  ClearLastExceptionRequest(ClearLastExceptionRequest&& from) noexcept
    : ClearLastExceptionRequest() {
    *this = ::std::move(from);
  }

  inline ClearLastExceptionRequest& operator=(const ClearLastExceptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearLastExceptionRequest& operator=(ClearLastExceptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearLastExceptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearLastExceptionRequest* internal_default_instance() {
    return reinterpret_cast<const ClearLastExceptionRequest*>(
               &_ClearLastExceptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClearLastExceptionRequest& a, ClearLastExceptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearLastExceptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearLastExceptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearLastExceptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearLastExceptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClearLastExceptionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClearLastExceptionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.ClearLastExceptionRequest";
  }
  protected:
  explicit ClearLastExceptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.ClearLastExceptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class ClearLastExceptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.ClearLastExceptionResponse) */ {
 public:
  inline ClearLastExceptionResponse() : ClearLastExceptionResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ClearLastExceptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearLastExceptionResponse(const ClearLastExceptionResponse& from);
  ClearLastExceptionResponse(ClearLastExceptionResponse&& from) noexcept
    : ClearLastExceptionResponse() {
    *this = ::std::move(from);
  }

  inline ClearLastExceptionResponse& operator=(const ClearLastExceptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearLastExceptionResponse& operator=(ClearLastExceptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearLastExceptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearLastExceptionResponse* internal_default_instance() {
    return reinterpret_cast<const ClearLastExceptionResponse*>(
               &_ClearLastExceptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ClearLastExceptionResponse& a, ClearLastExceptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearLastExceptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearLastExceptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearLastExceptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearLastExceptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClearLastExceptionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClearLastExceptionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.ClearLastExceptionResponse";
  }
  protected:
  explicit ClearLastExceptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.ClearLastExceptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class DestroyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.DestroyRequest) */ {
 public:
  inline DestroyRequest() : DestroyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DestroyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyRequest(const DestroyRequest& from);
  DestroyRequest(DestroyRequest&& from) noexcept
    : DestroyRequest() {
    *this = ::std::move(from);
  }

  inline DestroyRequest& operator=(const DestroyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyRequest& operator=(DestroyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyRequest*>(
               &_DestroyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DestroyRequest& a, DestroyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.DestroyRequest";
  }
  protected:
  explicit DestroyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.DestroyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class DestroyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.DestroyResponse) */ {
 public:
  inline DestroyResponse() : DestroyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DestroyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyResponse(const DestroyResponse& from);
  DestroyResponse(DestroyResponse&& from) noexcept
    : DestroyResponse() {
    *this = ::std::move(from);
  }

  inline DestroyResponse& operator=(const DestroyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyResponse& operator=(DestroyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyResponse* internal_default_instance() {
    return reinterpret_cast<const DestroyResponse*>(
               &_DestroyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DestroyResponse& a, DestroyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DestroyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DestroyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.DestroyResponse";
  }
  protected:
  explicit DestroyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.DestroyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class ExportTokenLibraryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.ExportTokenLibraryRequest) */ {
 public:
  inline ExportTokenLibraryRequest() : ExportTokenLibraryRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ExportTokenLibraryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportTokenLibraryRequest(const ExportTokenLibraryRequest& from);
  ExportTokenLibraryRequest(ExportTokenLibraryRequest&& from) noexcept
    : ExportTokenLibraryRequest() {
    *this = ::std::move(from);
  }

  inline ExportTokenLibraryRequest& operator=(const ExportTokenLibraryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportTokenLibraryRequest& operator=(ExportTokenLibraryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportTokenLibraryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportTokenLibraryRequest* internal_default_instance() {
    return reinterpret_cast<const ExportTokenLibraryRequest*>(
               &_ExportTokenLibraryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExportTokenLibraryRequest& a, ExportTokenLibraryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportTokenLibraryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportTokenLibraryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportTokenLibraryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportTokenLibraryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExportTokenLibraryRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExportTokenLibraryRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.ExportTokenLibraryRequest";
  }
  protected:
  explicit ExportTokenLibraryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.ExportTokenLibraryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class ExportTokenLibraryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2hasher.ExportTokenLibraryResponse) */ {
 public:
  inline ExportTokenLibraryResponse() : ExportTokenLibraryResponse(nullptr) {}
  ~ExportTokenLibraryResponse() override;
  explicit PROTOBUF_CONSTEXPR ExportTokenLibraryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportTokenLibraryResponse(const ExportTokenLibraryResponse& from);
  ExportTokenLibraryResponse(ExportTokenLibraryResponse&& from) noexcept
    : ExportTokenLibraryResponse() {
    *this = ::std::move(from);
  }

  inline ExportTokenLibraryResponse& operator=(const ExportTokenLibraryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportTokenLibraryResponse& operator=(ExportTokenLibraryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportTokenLibraryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportTokenLibraryResponse* internal_default_instance() {
    return reinterpret_cast<const ExportTokenLibraryResponse*>(
               &_ExportTokenLibraryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ExportTokenLibraryResponse& a, ExportTokenLibraryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportTokenLibraryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportTokenLibraryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportTokenLibraryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportTokenLibraryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportTokenLibraryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExportTokenLibraryResponse& from) {
    ExportTokenLibraryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportTokenLibraryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.ExportTokenLibraryResponse";
  }
  protected:
  explicit ExportTokenLibraryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2hasher.ExportTokenLibraryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class GetLastExceptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.GetLastExceptionRequest) */ {
 public:
  inline GetLastExceptionRequest() : GetLastExceptionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetLastExceptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastExceptionRequest(const GetLastExceptionRequest& from);
  GetLastExceptionRequest(GetLastExceptionRequest&& from) noexcept
    : GetLastExceptionRequest() {
    *this = ::std::move(from);
  }

  inline GetLastExceptionRequest& operator=(const GetLastExceptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastExceptionRequest& operator=(GetLastExceptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastExceptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastExceptionRequest* internal_default_instance() {
    return reinterpret_cast<const GetLastExceptionRequest*>(
               &_GetLastExceptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetLastExceptionRequest& a, GetLastExceptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastExceptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastExceptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastExceptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastExceptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLastExceptionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLastExceptionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.GetLastExceptionRequest";
  }
  protected:
  explicit GetLastExceptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.GetLastExceptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class GetLastExceptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2hasher.GetLastExceptionResponse) */ {
 public:
  inline GetLastExceptionResponse() : GetLastExceptionResponse(nullptr) {}
  ~GetLastExceptionResponse() override;
  explicit PROTOBUF_CONSTEXPR GetLastExceptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastExceptionResponse(const GetLastExceptionResponse& from);
  GetLastExceptionResponse(GetLastExceptionResponse&& from) noexcept
    : GetLastExceptionResponse() {
    *this = ::std::move(from);
  }

  inline GetLastExceptionResponse& operator=(const GetLastExceptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastExceptionResponse& operator=(GetLastExceptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastExceptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastExceptionResponse* internal_default_instance() {
    return reinterpret_cast<const GetLastExceptionResponse*>(
               &_GetLastExceptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetLastExceptionResponse& a, GetLastExceptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastExceptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastExceptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastExceptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastExceptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLastExceptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLastExceptionResponse& from) {
    GetLastExceptionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastExceptionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.GetLastExceptionResponse";
  }
  protected:
  explicit GetLastExceptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2hasher.GetLastExceptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class GetLastExceptionCodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.GetLastExceptionCodeRequest) */ {
 public:
  inline GetLastExceptionCodeRequest() : GetLastExceptionCodeRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetLastExceptionCodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastExceptionCodeRequest(const GetLastExceptionCodeRequest& from);
  GetLastExceptionCodeRequest(GetLastExceptionCodeRequest&& from) noexcept
    : GetLastExceptionCodeRequest() {
    *this = ::std::move(from);
  }

  inline GetLastExceptionCodeRequest& operator=(const GetLastExceptionCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastExceptionCodeRequest& operator=(GetLastExceptionCodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastExceptionCodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastExceptionCodeRequest* internal_default_instance() {
    return reinterpret_cast<const GetLastExceptionCodeRequest*>(
               &_GetLastExceptionCodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetLastExceptionCodeRequest& a, GetLastExceptionCodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastExceptionCodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastExceptionCodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastExceptionCodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastExceptionCodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLastExceptionCodeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLastExceptionCodeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.GetLastExceptionCodeRequest";
  }
  protected:
  explicit GetLastExceptionCodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.GetLastExceptionCodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class GetLastExceptionCodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2hasher.GetLastExceptionCodeResponse) */ {
 public:
  inline GetLastExceptionCodeResponse() : GetLastExceptionCodeResponse(nullptr) {}
  ~GetLastExceptionCodeResponse() override;
  explicit PROTOBUF_CONSTEXPR GetLastExceptionCodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLastExceptionCodeResponse(const GetLastExceptionCodeResponse& from);
  GetLastExceptionCodeResponse(GetLastExceptionCodeResponse&& from) noexcept
    : GetLastExceptionCodeResponse() {
    *this = ::std::move(from);
  }

  inline GetLastExceptionCodeResponse& operator=(const GetLastExceptionCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLastExceptionCodeResponse& operator=(GetLastExceptionCodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLastExceptionCodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLastExceptionCodeResponse* internal_default_instance() {
    return reinterpret_cast<const GetLastExceptionCodeResponse*>(
               &_GetLastExceptionCodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetLastExceptionCodeResponse& a, GetLastExceptionCodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLastExceptionCodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLastExceptionCodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLastExceptionCodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLastExceptionCodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLastExceptionCodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLastExceptionCodeResponse& from) {
    GetLastExceptionCodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastExceptionCodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.GetLastExceptionCodeResponse";
  }
  protected:
  explicit GetLastExceptionCodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigIDFieldNumber = 1,
  };
  // int32 configID = 1;
  void clear_configid();
  int32_t configid() const;
  void set_configid(int32_t value);
  private:
  int32_t _internal_configid() const;
  void _internal_set_configid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:g2hasher.GetLastExceptionCodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t configid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class InitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2hasher.InitRequest) */ {
 public:
  inline InitRequest() : InitRequest(nullptr) {}
  ~InitRequest() override;
  explicit PROTOBUF_CONSTEXPR InitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitRequest(const InitRequest& from);
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitRequest& from) {
    InitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.InitRequest";
  }
  protected:
  explicit InitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleNameFieldNumber = 1,
    kIniParamsFieldNumber = 2,
    kVerboseLoggingFieldNumber = 3,
  };
  // string moduleName = 1;
  void clear_modulename();
  const std::string& modulename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modulename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modulename();
  PROTOBUF_NODISCARD std::string* release_modulename();
  void set_allocated_modulename(std::string* modulename);
  private:
  const std::string& _internal_modulename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modulename(const std::string& value);
  std::string* _internal_mutable_modulename();
  public:

  // string iniParams = 2;
  void clear_iniparams();
  const std::string& iniparams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iniparams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iniparams();
  PROTOBUF_NODISCARD std::string* release_iniparams();
  void set_allocated_iniparams(std::string* iniparams);
  private:
  const std::string& _internal_iniparams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iniparams(const std::string& value);
  std::string* _internal_mutable_iniparams();
  public:

  // int32 verboseLogging = 3;
  void clear_verboselogging();
  int32_t verboselogging() const;
  void set_verboselogging(int32_t value);
  private:
  int32_t _internal_verboselogging() const;
  void _internal_set_verboselogging(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:g2hasher.InitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modulename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iniparams_;
    int32_t verboselogging_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class InitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.InitResponse) */ {
 public:
  inline InitResponse() : InitResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR InitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitResponse(const InitResponse& from);
  InitResponse(InitResponse&& from) noexcept
    : InitResponse() {
    *this = ::std::move(from);
  }

  inline InitResponse& operator=(const InitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitResponse& operator=(InitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitResponse* internal_default_instance() {
    return reinterpret_cast<const InitResponse*>(
               &_InitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InitResponse& a, InitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.InitResponse";
  }
  protected:
  explicit InitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.InitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class InitWithConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2hasher.InitWithConfigRequest) */ {
 public:
  inline InitWithConfigRequest() : InitWithConfigRequest(nullptr) {}
  ~InitWithConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR InitWithConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitWithConfigRequest(const InitWithConfigRequest& from);
  InitWithConfigRequest(InitWithConfigRequest&& from) noexcept
    : InitWithConfigRequest() {
    *this = ::std::move(from);
  }

  inline InitWithConfigRequest& operator=(const InitWithConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitWithConfigRequest& operator=(InitWithConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitWithConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitWithConfigRequest* internal_default_instance() {
    return reinterpret_cast<const InitWithConfigRequest*>(
               &_InitWithConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InitWithConfigRequest& a, InitWithConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitWithConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitWithConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitWithConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitWithConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitWithConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitWithConfigRequest& from) {
    InitWithConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitWithConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.InitWithConfigRequest";
  }
  protected:
  explicit InitWithConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleNameFieldNumber = 1,
    kIniParamsFieldNumber = 2,
    kConfigJsonFieldNumber = 3,
    kVerboseLoggingFieldNumber = 4,
  };
  // string moduleName = 1;
  void clear_modulename();
  const std::string& modulename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modulename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modulename();
  PROTOBUF_NODISCARD std::string* release_modulename();
  void set_allocated_modulename(std::string* modulename);
  private:
  const std::string& _internal_modulename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modulename(const std::string& value);
  std::string* _internal_mutable_modulename();
  public:

  // string iniParams = 2;
  void clear_iniparams();
  const std::string& iniparams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iniparams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iniparams();
  PROTOBUF_NODISCARD std::string* release_iniparams();
  void set_allocated_iniparams(std::string* iniparams);
  private:
  const std::string& _internal_iniparams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iniparams(const std::string& value);
  std::string* _internal_mutable_iniparams();
  public:

  // string configJson = 3;
  void clear_configjson();
  const std::string& configjson() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configjson(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configjson();
  PROTOBUF_NODISCARD std::string* release_configjson();
  void set_allocated_configjson(std::string* configjson);
  private:
  const std::string& _internal_configjson() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configjson(const std::string& value);
  std::string* _internal_mutable_configjson();
  public:

  // int32 verboseLogging = 4;
  void clear_verboselogging();
  int32_t verboselogging() const;
  void set_verboselogging(int32_t value);
  private:
  int32_t _internal_verboselogging() const;
  void _internal_set_verboselogging(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:g2hasher.InitWithConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modulename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iniparams_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configjson_;
    int32_t verboselogging_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class InitWithConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2hasher.InitWithConfigResponse) */ {
 public:
  inline InitWithConfigResponse() : InitWithConfigResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR InitWithConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitWithConfigResponse(const InitWithConfigResponse& from);
  InitWithConfigResponse(InitWithConfigResponse&& from) noexcept
    : InitWithConfigResponse() {
    *this = ::std::move(from);
  }

  inline InitWithConfigResponse& operator=(const InitWithConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitWithConfigResponse& operator=(InitWithConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitWithConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitWithConfigResponse* internal_default_instance() {
    return reinterpret_cast<const InitWithConfigResponse*>(
               &_InitWithConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(InitWithConfigResponse& a, InitWithConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitWithConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitWithConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitWithConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitWithConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitWithConfigResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitWithConfigResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.InitWithConfigResponse";
  }
  protected:
  explicit InitWithConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2hasher.InitWithConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class ProcessRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2hasher.ProcessRequest) */ {
 public:
  inline ProcessRequest() : ProcessRequest(nullptr) {}
  ~ProcessRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessRequest(const ProcessRequest& from);
  ProcessRequest(ProcessRequest&& from) noexcept
    : ProcessRequest() {
    *this = ::std::move(from);
  }

  inline ProcessRequest& operator=(const ProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessRequest& operator=(ProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessRequest*>(
               &_ProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProcessRequest& a, ProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessRequest& from) {
    ProcessRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.ProcessRequest";
  }
  protected:
  explicit ProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
  };
  // string record = 1;
  void clear_record();
  const std::string& record() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_record(ArgT0&& arg0, ArgT... args);
  std::string* mutable_record();
  PROTOBUF_NODISCARD std::string* release_record();
  void set_allocated_record(std::string* record);
  private:
  const std::string& _internal_record() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_record(const std::string& value);
  std::string* _internal_mutable_record();
  public:

  // @@protoc_insertion_point(class_scope:g2hasher.ProcessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr record_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// -------------------------------------------------------------------

class ProcessResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2hasher.ProcessResponse) */ {
 public:
  inline ProcessResponse() : ProcessResponse(nullptr) {}
  ~ProcessResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessResponse(const ProcessResponse& from);
  ProcessResponse(ProcessResponse&& from) noexcept
    : ProcessResponse() {
    *this = ::std::move(from);
  }

  inline ProcessResponse& operator=(const ProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessResponse& operator=(ProcessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessResponse*>(
               &_ProcessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ProcessResponse& a, ProcessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessResponse& from) {
    ProcessResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2hasher.ProcessResponse";
  }
  protected:
  explicit ProcessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2hasher.ProcessResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2hasher_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClearLastExceptionRequest

// -------------------------------------------------------------------

// ClearLastExceptionResponse

// -------------------------------------------------------------------

// DestroyRequest

// -------------------------------------------------------------------

// DestroyResponse

// -------------------------------------------------------------------

// ExportTokenLibraryRequest

// -------------------------------------------------------------------

// ExportTokenLibraryResponse

// string result = 1;
inline void ExportTokenLibraryResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& ExportTokenLibraryResponse::result() const {
  // @@protoc_insertion_point(field_get:g2hasher.ExportTokenLibraryResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportTokenLibraryResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.ExportTokenLibraryResponse.result)
}
inline std::string* ExportTokenLibraryResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2hasher.ExportTokenLibraryResponse.result)
  return _s;
}
inline const std::string& ExportTokenLibraryResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void ExportTokenLibraryResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportTokenLibraryResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportTokenLibraryResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2hasher.ExportTokenLibraryResponse.result)
  return _impl_.result_.Release();
}
inline void ExportTokenLibraryResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.ExportTokenLibraryResponse.result)
}

// -------------------------------------------------------------------

// GetLastExceptionRequest

// -------------------------------------------------------------------

// GetLastExceptionResponse

// string result = 1;
inline void GetLastExceptionResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& GetLastExceptionResponse::result() const {
  // @@protoc_insertion_point(field_get:g2hasher.GetLastExceptionResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLastExceptionResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.GetLastExceptionResponse.result)
}
inline std::string* GetLastExceptionResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2hasher.GetLastExceptionResponse.result)
  return _s;
}
inline const std::string& GetLastExceptionResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void GetLastExceptionResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLastExceptionResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLastExceptionResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2hasher.GetLastExceptionResponse.result)
  return _impl_.result_.Release();
}
inline void GetLastExceptionResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.GetLastExceptionResponse.result)
}

// -------------------------------------------------------------------

// GetLastExceptionCodeRequest

// -------------------------------------------------------------------

// GetLastExceptionCodeResponse

// int32 configID = 1;
inline void GetLastExceptionCodeResponse::clear_configid() {
  _impl_.configid_ = 0;
}
inline int32_t GetLastExceptionCodeResponse::_internal_configid() const {
  return _impl_.configid_;
}
inline int32_t GetLastExceptionCodeResponse::configid() const {
  // @@protoc_insertion_point(field_get:g2hasher.GetLastExceptionCodeResponse.configID)
  return _internal_configid();
}
inline void GetLastExceptionCodeResponse::_internal_set_configid(int32_t value) {
  
  _impl_.configid_ = value;
}
inline void GetLastExceptionCodeResponse::set_configid(int32_t value) {
  _internal_set_configid(value);
  // @@protoc_insertion_point(field_set:g2hasher.GetLastExceptionCodeResponse.configID)
}

// -------------------------------------------------------------------

// InitRequest

// string moduleName = 1;
inline void InitRequest::clear_modulename() {
  _impl_.modulename_.ClearToEmpty();
}
inline const std::string& InitRequest::modulename() const {
  // @@protoc_insertion_point(field_get:g2hasher.InitRequest.moduleName)
  return _internal_modulename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitRequest::set_modulename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modulename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.InitRequest.moduleName)
}
inline std::string* InitRequest::mutable_modulename() {
  std::string* _s = _internal_mutable_modulename();
  // @@protoc_insertion_point(field_mutable:g2hasher.InitRequest.moduleName)
  return _s;
}
inline const std::string& InitRequest::_internal_modulename() const {
  return _impl_.modulename_.Get();
}
inline void InitRequest::_internal_set_modulename(const std::string& value) {
  
  _impl_.modulename_.Set(value, GetArenaForAllocation());
}
inline std::string* InitRequest::_internal_mutable_modulename() {
  
  return _impl_.modulename_.Mutable(GetArenaForAllocation());
}
inline std::string* InitRequest::release_modulename() {
  // @@protoc_insertion_point(field_release:g2hasher.InitRequest.moduleName)
  return _impl_.modulename_.Release();
}
inline void InitRequest::set_allocated_modulename(std::string* modulename) {
  if (modulename != nullptr) {
    
  } else {
    
  }
  _impl_.modulename_.SetAllocated(modulename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modulename_.IsDefault()) {
    _impl_.modulename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.InitRequest.moduleName)
}

// string iniParams = 2;
inline void InitRequest::clear_iniparams() {
  _impl_.iniparams_.ClearToEmpty();
}
inline const std::string& InitRequest::iniparams() const {
  // @@protoc_insertion_point(field_get:g2hasher.InitRequest.iniParams)
  return _internal_iniparams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitRequest::set_iniparams(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iniparams_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.InitRequest.iniParams)
}
inline std::string* InitRequest::mutable_iniparams() {
  std::string* _s = _internal_mutable_iniparams();
  // @@protoc_insertion_point(field_mutable:g2hasher.InitRequest.iniParams)
  return _s;
}
inline const std::string& InitRequest::_internal_iniparams() const {
  return _impl_.iniparams_.Get();
}
inline void InitRequest::_internal_set_iniparams(const std::string& value) {
  
  _impl_.iniparams_.Set(value, GetArenaForAllocation());
}
inline std::string* InitRequest::_internal_mutable_iniparams() {
  
  return _impl_.iniparams_.Mutable(GetArenaForAllocation());
}
inline std::string* InitRequest::release_iniparams() {
  // @@protoc_insertion_point(field_release:g2hasher.InitRequest.iniParams)
  return _impl_.iniparams_.Release();
}
inline void InitRequest::set_allocated_iniparams(std::string* iniparams) {
  if (iniparams != nullptr) {
    
  } else {
    
  }
  _impl_.iniparams_.SetAllocated(iniparams, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iniparams_.IsDefault()) {
    _impl_.iniparams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.InitRequest.iniParams)
}

// int32 verboseLogging = 3;
inline void InitRequest::clear_verboselogging() {
  _impl_.verboselogging_ = 0;
}
inline int32_t InitRequest::_internal_verboselogging() const {
  return _impl_.verboselogging_;
}
inline int32_t InitRequest::verboselogging() const {
  // @@protoc_insertion_point(field_get:g2hasher.InitRequest.verboseLogging)
  return _internal_verboselogging();
}
inline void InitRequest::_internal_set_verboselogging(int32_t value) {
  
  _impl_.verboselogging_ = value;
}
inline void InitRequest::set_verboselogging(int32_t value) {
  _internal_set_verboselogging(value);
  // @@protoc_insertion_point(field_set:g2hasher.InitRequest.verboseLogging)
}

// -------------------------------------------------------------------

// InitResponse

// -------------------------------------------------------------------

// InitWithConfigRequest

// string moduleName = 1;
inline void InitWithConfigRequest::clear_modulename() {
  _impl_.modulename_.ClearToEmpty();
}
inline const std::string& InitWithConfigRequest::modulename() const {
  // @@protoc_insertion_point(field_get:g2hasher.InitWithConfigRequest.moduleName)
  return _internal_modulename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitWithConfigRequest::set_modulename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modulename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.InitWithConfigRequest.moduleName)
}
inline std::string* InitWithConfigRequest::mutable_modulename() {
  std::string* _s = _internal_mutable_modulename();
  // @@protoc_insertion_point(field_mutable:g2hasher.InitWithConfigRequest.moduleName)
  return _s;
}
inline const std::string& InitWithConfigRequest::_internal_modulename() const {
  return _impl_.modulename_.Get();
}
inline void InitWithConfigRequest::_internal_set_modulename(const std::string& value) {
  
  _impl_.modulename_.Set(value, GetArenaForAllocation());
}
inline std::string* InitWithConfigRequest::_internal_mutable_modulename() {
  
  return _impl_.modulename_.Mutable(GetArenaForAllocation());
}
inline std::string* InitWithConfigRequest::release_modulename() {
  // @@protoc_insertion_point(field_release:g2hasher.InitWithConfigRequest.moduleName)
  return _impl_.modulename_.Release();
}
inline void InitWithConfigRequest::set_allocated_modulename(std::string* modulename) {
  if (modulename != nullptr) {
    
  } else {
    
  }
  _impl_.modulename_.SetAllocated(modulename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modulename_.IsDefault()) {
    _impl_.modulename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.InitWithConfigRequest.moduleName)
}

// string iniParams = 2;
inline void InitWithConfigRequest::clear_iniparams() {
  _impl_.iniparams_.ClearToEmpty();
}
inline const std::string& InitWithConfigRequest::iniparams() const {
  // @@protoc_insertion_point(field_get:g2hasher.InitWithConfigRequest.iniParams)
  return _internal_iniparams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitWithConfigRequest::set_iniparams(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iniparams_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.InitWithConfigRequest.iniParams)
}
inline std::string* InitWithConfigRequest::mutable_iniparams() {
  std::string* _s = _internal_mutable_iniparams();
  // @@protoc_insertion_point(field_mutable:g2hasher.InitWithConfigRequest.iniParams)
  return _s;
}
inline const std::string& InitWithConfigRequest::_internal_iniparams() const {
  return _impl_.iniparams_.Get();
}
inline void InitWithConfigRequest::_internal_set_iniparams(const std::string& value) {
  
  _impl_.iniparams_.Set(value, GetArenaForAllocation());
}
inline std::string* InitWithConfigRequest::_internal_mutable_iniparams() {
  
  return _impl_.iniparams_.Mutable(GetArenaForAllocation());
}
inline std::string* InitWithConfigRequest::release_iniparams() {
  // @@protoc_insertion_point(field_release:g2hasher.InitWithConfigRequest.iniParams)
  return _impl_.iniparams_.Release();
}
inline void InitWithConfigRequest::set_allocated_iniparams(std::string* iniparams) {
  if (iniparams != nullptr) {
    
  } else {
    
  }
  _impl_.iniparams_.SetAllocated(iniparams, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iniparams_.IsDefault()) {
    _impl_.iniparams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.InitWithConfigRequest.iniParams)
}

// string configJson = 3;
inline void InitWithConfigRequest::clear_configjson() {
  _impl_.configjson_.ClearToEmpty();
}
inline const std::string& InitWithConfigRequest::configjson() const {
  // @@protoc_insertion_point(field_get:g2hasher.InitWithConfigRequest.configJson)
  return _internal_configjson();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitWithConfigRequest::set_configjson(ArgT0&& arg0, ArgT... args) {
 
 _impl_.configjson_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.InitWithConfigRequest.configJson)
}
inline std::string* InitWithConfigRequest::mutable_configjson() {
  std::string* _s = _internal_mutable_configjson();
  // @@protoc_insertion_point(field_mutable:g2hasher.InitWithConfigRequest.configJson)
  return _s;
}
inline const std::string& InitWithConfigRequest::_internal_configjson() const {
  return _impl_.configjson_.Get();
}
inline void InitWithConfigRequest::_internal_set_configjson(const std::string& value) {
  
  _impl_.configjson_.Set(value, GetArenaForAllocation());
}
inline std::string* InitWithConfigRequest::_internal_mutable_configjson() {
  
  return _impl_.configjson_.Mutable(GetArenaForAllocation());
}
inline std::string* InitWithConfigRequest::release_configjson() {
  // @@protoc_insertion_point(field_release:g2hasher.InitWithConfigRequest.configJson)
  return _impl_.configjson_.Release();
}
inline void InitWithConfigRequest::set_allocated_configjson(std::string* configjson) {
  if (configjson != nullptr) {
    
  } else {
    
  }
  _impl_.configjson_.SetAllocated(configjson, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.configjson_.IsDefault()) {
    _impl_.configjson_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.InitWithConfigRequest.configJson)
}

// int32 verboseLogging = 4;
inline void InitWithConfigRequest::clear_verboselogging() {
  _impl_.verboselogging_ = 0;
}
inline int32_t InitWithConfigRequest::_internal_verboselogging() const {
  return _impl_.verboselogging_;
}
inline int32_t InitWithConfigRequest::verboselogging() const {
  // @@protoc_insertion_point(field_get:g2hasher.InitWithConfigRequest.verboseLogging)
  return _internal_verboselogging();
}
inline void InitWithConfigRequest::_internal_set_verboselogging(int32_t value) {
  
  _impl_.verboselogging_ = value;
}
inline void InitWithConfigRequest::set_verboselogging(int32_t value) {
  _internal_set_verboselogging(value);
  // @@protoc_insertion_point(field_set:g2hasher.InitWithConfigRequest.verboseLogging)
}

// -------------------------------------------------------------------

// InitWithConfigResponse

// -------------------------------------------------------------------

// ProcessRequest

// string record = 1;
inline void ProcessRequest::clear_record() {
  _impl_.record_.ClearToEmpty();
}
inline const std::string& ProcessRequest::record() const {
  // @@protoc_insertion_point(field_get:g2hasher.ProcessRequest.record)
  return _internal_record();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessRequest::set_record(ArgT0&& arg0, ArgT... args) {
 
 _impl_.record_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.ProcessRequest.record)
}
inline std::string* ProcessRequest::mutable_record() {
  std::string* _s = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:g2hasher.ProcessRequest.record)
  return _s;
}
inline const std::string& ProcessRequest::_internal_record() const {
  return _impl_.record_.Get();
}
inline void ProcessRequest::_internal_set_record(const std::string& value) {
  
  _impl_.record_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessRequest::_internal_mutable_record() {
  
  return _impl_.record_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessRequest::release_record() {
  // @@protoc_insertion_point(field_release:g2hasher.ProcessRequest.record)
  return _impl_.record_.Release();
}
inline void ProcessRequest::set_allocated_record(std::string* record) {
  if (record != nullptr) {
    
  } else {
    
  }
  _impl_.record_.SetAllocated(record, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.record_.IsDefault()) {
    _impl_.record_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.ProcessRequest.record)
}

// -------------------------------------------------------------------

// ProcessResponse

// string result = 1;
inline void ProcessResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& ProcessResponse::result() const {
  // @@protoc_insertion_point(field_get:g2hasher.ProcessResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2hasher.ProcessResponse.result)
}
inline std::string* ProcessResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2hasher.ProcessResponse.result)
  return _s;
}
inline const std::string& ProcessResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void ProcessResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2hasher.ProcessResponse.result)
  return _impl_.result_.Release();
}
inline void ProcessResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2hasher.ProcessResponse.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace g2hasher

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_g2hasher_2eproto
